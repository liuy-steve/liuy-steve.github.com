---
layout: post
title: "第三章 目标文件里有什么"
description: ""
category: 
tags: [字符]
---
{% include JB/setup %}

第3章 目标文件里有什么
=========================
这一章可以说是基础部分的重点，无论是要分析链接还是装载过程，首先要对目标文件里有什么做到了如指掌。
这样才不会在后面的分析过程中遇到障碍。

**ELF文件的类型与结构描述**

我以前一直好奇，shell是如何区分一个不带后缀的文件是执行文件，还是库，还是一个文本文档？学习这一章以后，
对ELF文件的鉴别应该很清楚了。首先，ELF文件带有魔数，如果魔术校验不正确的话，shell应该是不会将文件视为可执行文件的。
其次，文件头部中出去magic num以外，还有各种其他的信息。例如，e_iden成员中的Class Data Version ABI等等其他关键的字段。
试想，如果一个TXT文件试图伪装成一个ELF文件，那么他至少在文件头部要卯足这些结构体的描述。

    书中有一段原文是这样描述的：
    “从上面输出的结果可以看到，ELF的文件头中定义了ELF魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI版本、EFL重定位类型、硬件平台、硬件平台版本、入口地址、程序头出口和长度、段表的位置和长度以及段的数量等。”
    
了解了这些自然能够想到，为什么32位机器上无法运行64位的程序？为什么在诸如跨平台编译器上编译出来的程序无法直接运行？当然也能够解释为什么shell可以将
“helloworld(可执行文件)”这样的命令后面附带的文件装载到内存中，原来ELF文件中是有这么多丰富的信息哦！特别需要注意的是，位数信息，大小端种类这个信息是直接放在文件头16个字节中的。因为先解析他们对后面解析至关重要。

ELF文件除了文件头以外，就是各种段的组合。而段有个类似索引的结构，叫做段表。


**ELF的段表结构**

什么是段表呢？段表里有什么东西呢？

我觉得段表可以表示为段的索引结构。用来存放ELF文件各个段的信息。书中一直重复强调了section，这个section（段）和经常碰到的 segment error中的segment（段）还真不是一回事，有啥区别呢？书中在装载那一部分有详细的介绍。section更注重ELF的静态结构。

首先试想一下，如果你是操作系统？在解析完ELF文件头以后，如何解析其他的段的结构呢？

下面，我们的用户执行了一条readelf的命令，希望我们显示全部的段信息。怎么返回呢？从文件头里找找吧。这里可以发现，在文件头中有个比较重要的字段 **e_shoff** 。他标识 “Start pf sectopm headers: *** 段表在文件中的偏移。”
有个这个偏移以后，我们就可以找到段表的位置。在通过e_shentsize 和 e_shnum可以知道段表描述符的到校和个数。这样就可以计算出每个段表描述符的位置信息和整个段表的大小。
有个这个，在去解读每个段的信息就比较容易了。

我这里描述的比较简单，当然还有另外一些详细的过程没有描述，例如：是怎么样根据短表字符串表来观察每个段的名字的？应该是通过段表中的段名字符串描述符得到段名字符串段在文件中的偏移以后，在
段表描述符中的sh_name字段来查找该段的名字在段表字符串段中的偏移。一些其他的过程有的时候，自己多想想，还是很有乐趣的。

最后引用书上的一句原话“由此我们可以得出结论，只有分析ELF文件头，就可以得到段表和段表字符串表的位置，从而解析整个ELF文件”。

**符号表和重定位表**

符号对于链接的作用举足轻重。没有符号，链接无法完成。符号就像目标文件的胶水一样。也想乐高玩具的卡槽。
对于链接时需要提供出去给链接器用的东东，无论是变量还是函数，在链接的过程都用符号做唯一的标识。为此，
不同语言甚至同种语言的各个编译器，甚至于编译器的各个版本对于符号的解释规则都不完全相同，造成了ABI的不兼容。我就曾经碰见过由于编译器升级造成的ABI不兼容的问题。当然还不只是符号的问题。

对于符号的问题，曾今出国缺少“extern C”而没能找到C++描述规则的符号的问题，还碰到过编写的DLL由于没有
导出符号导致链接不过的问题。对于符号的深刻教训还远不只这些。

对于符号我们可以明确的是，符号是有大小的（但不都是有大小的）。不同于