---
layout: post
title: "字符集的问题"
description: "描述字符编码的问题和解决方法"
category: 
tags: [字符]
---
{% include JB/setup %}

**写在前面的话**
----------

字符的问题由来已久。windows上命名的文件夹经过samba共享传到linux上，中文为啥是乱码？URL中的中文字符为啥是%后面什么什么？
如果这些关于字符的问题你没有困惑，那么该post可以不用再往后看了。如果你对字符的问题有一些疑惑？那么来这里寻找答案吧。

本文的内容源引自[一篇CSDN帖子](http://blog.csdn.net/fmddlmyy/article/details/372148)

新写一篇post准备push的时候，总会发现github给我发来邮件，说我的page发布失败了。
运行本地jekyll以后发现，是字符的问题。只支持UTF-8 with no BOM的格式。而我在PC端的文本编辑器UE初始化的格式都是UTF-8 with BOM的。

那么什么是BOM呢？什么又是UTF-8呢？ 和UTF-16是什么关系呢？和GB2312是一个东西么？？

首先看我的UE可以保存的文本格式
如图 

![截图示意]({{ site.img_url }}/20130902/type.jpg)

先不提换行符的不同，光不同的格式就有7 8 种。那么每种有什么不同？

先来看看概念吧。


> 1. 字符编码、内码，顺带介绍汉字编码
> 
>      字符必须编码后才能被计算机处理。计算机使用的缺省编码方式就是计算机的内码。早期的计算机使用7位的ASCII编码，为了处理汉字，程序员设计了用于简体中文的GB2312和用于繁体中文的big5。
> 
>     GB2312(1980年)一共收录了7445个字符，包括6763个汉字和682个其它符号。汉字区的内码范围高字节从B0-F7，低字节从A1-FE，占用的码位是72\*94=6768。其中有5个空位是D7FA-D7FE。
> 
>     GB2312支持的汉字太少。1995年的汉字扩展规范GBK1.0收录了21886个符号，它分为汉字区和图形符号区。汉字区包括21003个字符。2000年的GB18030是取代GBK1.0的正式国家标准。该标准收录了27484个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字。现在的PC平台必须支持GB18030，对嵌入式产品暂不作要求。所以手机、MP3一般只支持GB2312。
> 
>     从ASCII、GB2312、GBK到GB18030，这些编码方法是向下兼容的，即同一个字符在这些方案中总是有相同的编码，后面的标准支持更多的字符。在这些编码中，英文和中文可以统一地处理。区分中文编码的方法是高字节的最高位不为0。按照程序员的称呼，GB2312、GBK到GB18030都属于双字节字符集
> (DBCS)。
> 
>     有的中文Windows的缺省内码还是GBK，可以通过GB18030升级包升级到GB18030。不过GB18030相对GBK增加的字符，普通人是很难用到的，通常我们还是用GBK指代中文Windows内码。
> 
>     这里还有一些细节：
> 
>     GB2312的原文还是区位码，从区位码到内码，需要在高字节和低字节上分别加上A0。
> 
>     在DBCS中，GB内码的存储格式始终是big endian，即高位在前。
> 
>     GB2312的两个字节的最高位都是1。但符合这个条件的码位只有128\*128=16384个。所以GBK和GB18030的低字节最高位都可能不是1。不过这不影响DBCS字符流的解析：在读取DBCS字符流时，只要遇到高位为1的字节，就可以将下两个字节作为一个双字节编码，而不用管低字节的高位是什么。
>         
>     这里解释一下大小端的问题。我曾经以为大端就是高位在前，低位在后，小端反之。其实有着更准确的定义。
>     大端指在存储的时候MSB位于低地址而LSB位于高地址（想象一下VC的memory窗口），而在网络传输的时候MSB位于bit流前部而LSB位于后部。小端反之。因此再和别人谈论关于大小端的问题的时候，不能够说使用大端序而要准确的说出“网络字节序”。
> 
> 
> 2. Unicode、UCS和UTF
> 
>     前面提到从ASCII、GB2312、GBK到GB18030的编码方法是向下兼容的。而Unicode只与ASCII兼容（更准确地说，是与ISO-8859-1兼容），与GB码不兼容。例如“汉”字的Unicode编码是6C49，而GB码是BABA。
> 
>     Unicode也是一种字符编码方法，不过它是由国际组织设计，可以容纳全世界所有语言文字的编码方案。Unicode的学名是"Universal
> Multiple-Octet Coded Character Set"，简称为UCS。UCS可以看作是"Unicode Character
> Set"的缩写。
> 
>     根据维[基百科全书](http://zh.wikipedia.org/wiki/)的记载：
>         历史上存在两个试图独立设计Unicode的组织，即国际标准化组织（ISO）和一个软件制造商的协会（unicode.org）。ISO开发了ISO
> 10646项目，Unicode协会开发了Unicode项目。
> 
>         在1991年前后，双方都认识到世界不需要两个不兼容的字符集。于是它们开始合并双方的工作成果，并为创立一个单一编码表而协同工作。从Unicode2.0开始，Unicode项目采用了与ISO
> 10646-1相同的字库和字码。
> 
>         目前两个项目仍都存在，并独立地公布各自的标准。Unicode协会现在的最新版本是2005年的Unicode 4.1.0。ISO的最新标准是10646-3:2003。
> 
>     UCS规定了怎么用多个字节表示各种文字。怎样传输这些编码，是由UTF(UCS Transformation Format)规范规定的，常见的UTF规范包括UTF-8、UTF-7、UTF-16。
> 
>     IETF的RFC2781和RFC3629以RFC的一贯风格，清晰、明快又不失严谨地描述了UTF-16和UTF-8的编码方法。我总是记不得IETF是Internet
> Engineering Task Force的缩写。但IETF负责维护的RFC是Internet上一切规范的基础。
> 
> 3. UCS-2、UCS-4、BMP
>  
>     UCS有两种格式：UCS-2和UCS-4。顾名思义，UCS-2就是用两个字节编码，UCS-4就是用4个字节（实际上只用了31位，最高位必须为0）编码。下面让我们做一些简单的数学游戏：
> 
>     UCS-2有2^16=65536个码位，UCS-4有2^31=2147483648个码位。
> 
>     UCS-4根据最高位为0的最高字节分成2^7=128个group。每个group再根据次高字节分为256个plane。每个plane根据第3个字节分为256行
> (rows)，每行包含256个cells。当然同一行的cells只是最后一个字节不同，其余都相同。
> 
>     group 0的plane 0被称作Basic Multilingual Plane, 即BMP。或者说UCS-4中，高两个字节为0的码位被称作BMP。
> 
>     将UCS-4的BMP去掉前面的两个零字节就得到了UCS-2。在UCS-2的两个字节前加上两个零字节，就得到了UCS-4的BMP。而目前的UCS-4规范中还没有任何字符被分配在BMP之外。
> 
> 
> 4. UTF编码
>  
> 
>     UTF-8就是以8位为单元对UCS进行编码。从UCS-2到UTF-8的编码方式如下：
> 
>     UCS-2编码(16进制)    UTF-8 字节流(二进制)
>     0000 - 007F           0xxxxxxx
>     0080 - 07FF           110xxxxx 10xxxxxx
>     0800 - FFFF           1110xxxx 10xxxxxx 10xxxxxx
> 
>     例如“汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以肯定要用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 110001 001001，
> 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。
> 
>     读者可以用记事本测试一下我们的编码是否正确。
> 
>     UTF-16以16位为单元对UCS进行编码。对于小于0x10000的UCS码，UTF-16编码就等于UCS码对应的16位无符号整数。对于不小于0x10000的UCS码，定义了一个算法。不过由于实际使用的UCS2，或者UCS4的BMP必然小于0x10000，所以就目前而言，可以认为UTF-16和UCS-2基本相同。但UCS-2只是一个编码方案，UTF-16却要用于实际的传输，所以就不得不考虑字节序的问题。



好了，概念介绍完了，现在开始动手吧。

在UE中写点东西

***12345abcde中文***

然后分别保存为各种不同格式的文本。

首先是UTF 带BOM的

![UTF-8-BOM]({{ site.img_url }}/20130902/utf8-bom.jpg)

看文件的二进制

00000000h: EF BB BF 31 32 33 34 35 61 62 63 64 65 E4 B8 AD ; 锘?2345abcde涓?

00000010h: E6 96 87 0D 0A                                  ; 鏂?.

文件以标识UTF-8的所谓BOM0xEF BB BF 开头。而后面ASCII码部分则与ASCII码表对应得上，只是后面的中文字符被编码为UTF-8的。

再来看看不带BOM的UTF-8文件

![UTF-8-NOBOM]({{ site.img_url }}/20130902/utf8-nobom.jpg)

00000000h: 31 32 33 34 35 61 62 63 64 65 E4 B8 AD E6 96 87 ; 12345abcde涓枃

00000010h: 0D 0A                                           ; ..

少了什么呢？仅仅是BOM那三个字节。

接下来是UTF-16 带BOM的。

![UTF-16-BOM]({{ site.img_url }}/20130902/utf16-bom.jpg)

00000000h: FF FE 31 00 32 00 33 00 34 00 35 00 61 00 62 00 ; ?.2.3.4.5.a.b.

00000010h: 63 00 64 00 65 00 2D 4E 87 65 0D 00 0A 00       ; c.d.e.-N噀....

0xFFFE 标识了改UTF-16文件实际上是小端序本地存储的。因为我正在用PC写POST嘛。ASCII码都变为两个字节的了，而且MSB在高位，LSB在低位。

UTF-16 无BOM的

![UTF-16-NOBOM]({{ site.img_url }}/20130902/utf16-nobom.jpg)

接着分别是大端本地存储序的UTF-16和ASCII的。

![截图示意]({{ site.img_url }}/20130902/utf16-bom-bigendian.jpg)

![截图示意]({{ site.img_url }}/20130902/utf16-nobom-bigendian.jpg)

![截图示意]({{ site.img_url }}/20130902/UNICODE-ASCII.jpg)